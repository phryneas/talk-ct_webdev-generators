import { Head, Notes, Image, Appear, components as C, Split } from "mdx-deck";
import { CodeSurfer } from "mdx-deck-code-surfer";

export { default as theme } from "./theme";
export { components } from "mdx-deck-code-surfer";

<Head>
  <title>Async Generators</title>
</Head>

# JavaScript Generators

---

```typescript JavaScript Generators
function* agenda() {
  yield "obligatory introduction";
  yield "new syntax";
  yield "basics";
  yield "asynchronous behaviour";
  yield "flow control from the caller side";
  yield "generator use-case: early implementation of async/await";
  yield "generator use-case: sagas";
}
```

---

# About me

<C.ul>
  <C.li>
    Lenz Weber (<em>@phry</em> on Twitter, <em>phryneas</em> everywhere else)
  </C.li>
  <C.li>
    Developer at
    <img
      src="./assets/mayflower_logo_transparent.png"
      lang="typescript"
      style={{
        height: "1.3em",
        verticalAlign: "bottom",
        position: "relative",
        top: "5px",
        left: "-5px"
      }}
    />
  </C.li>
  <C.li>Working in professional web development since 15 years</C.li>
  <C.li>In love with the Web, Open Source, Linux and Security</C.li>
  <C.li>Just getting used to conference speaking, so bear with me</C.li>
</C.ul>

---

# Let's get to know Generators

---

```typescript Syntax Basics
function* myFirstGenerator() {
  yield "some-return-value";
  yield "another-return-value";
}

const myGeneratorInstance = myFirstGenerator();
----
*
1[1] > the asterisk marks a function as Generator Function
2[1],3[1] > use yield multiple times to return multiple values
6[5:7] > call like a function to get your Generator Object
```

---

```typescript Usage Basics: the for-of-loop
function* myFirstGenerator() {
  yield "some-return-value";
  yield "another-return-value";
}

for (const value of myFirstGenerator()) {
  console.log(value);
}
```

---

```typescript Usage Basics: using the Iterable protocol
function* myFirstGenerator() {
  yield "some-return-value";
  yield "another-return-value";
}

const iterableObject = myFirstGenerator();

let nextValue = iterableObject.next();
while (!nextValue.done) {
  console.log(nextValue.value);

  nextValue = iterableObject.next();
}
```

---

```typescript Asynchronous Behaviour: yield steps out of the Generator
function* myGenerator() {
  console.log("generator started");

  console.log("yielding first value");
  yield "some-return-value";
  console.log("yielding second value");
  yield "another-return-value";
  console.log("generator ends");
}

let nextValue;
const iterableObject = myGenerator();
console.log("generator created");
console.log("calling first next()");
nextValue = iterableObject.next();
console.log("got first return value", nextValue);
console.log("calling second next()");
nextValue = iterableObject.next();
console.log("got second return value", nextValue);
console.log("calling third next()");
nextValue = iterableObject.next();
console.log("got third value", nextValue);
----
*
12 > // calling myFirstGenerator()
13 > generator created
14,15 > calling first next()
2 > generator started
4,5 > yielding first value
16 > got first return value { done: false, value: "yielding first value" }
17,18 > got second next()
6,7 > yielding second value
19 > got second return value { done: false, value: "yielding second value" }
20,21 > calling third next()
8 > generator ends
22 > got third value { done: true, value: undefined }
```

---

```typescript Flow Control from the Caller: passing values into a running Generator Function
function* sumGenerator() {
  let sum = 0;
  while (true) {
    const value = yield sum;
    console.log("got passed", value);
    sum += value;
  }
}

const iterableObject = sumGenerator();
for (const add of [1, 2, 3]) {
  const returnedValue = iterableObject.next(add).value;
  console.log("returned value is", returnedValue);
}
```

---

# The chicken-egg-problem of passing values in both directions

If we pass in a value to be used before the first `yield` and at the same time use the `yield` keyword to access values passed in, we can never access the first value that is passed in.

> â‡’ The first time `Iterator.prototype.next(value)` is called, the value goes straight to `/dev/null`!

### Possile solutions:

- **invert the problem**: call `next` once just to get the generator started, without using the return value.
- **don't pass the first value to `next`**, but as an argument to the Generator Function call itself.

### Both solutions require the user of your generator to use it accordingly, so write some documentation.

---

```typescript Example for the "inverted" solution
function* sumGenerator() {
  let sum = 0;
  while (true) {
    const value = yield sum;
    console.log("got passed", value);
    sum += value;
  }
}

const iterableObject = sumGenerator();
iterableObject.next();
for (const add of [1, 2, 3]) {
  const returnedValue = iterableObject.next(add).value;
  console.log("returned value is", returnedValue);
}
----
*
10 > create the generator
11 > start the generator
2
4[5:7] > yield 0;
12 > const add = 1;
13[4:9] > next(1);
4[1:4] > got 1
5 > conosle.log("got passed 1")
6 > sum = 0 + 1;
4[5:7] > yield 1;
13[1:3,10:12] > { done: false, value: 1 }
14 > console.log("returned value is", 1)
12 > const add = 2; // et cetera
```

---

```typescript Example for the "function argument" solution
function* sumGenerator(firstPassedValue) {
  let sum = firstPassedValue;
  while (true) {
    const value = yield sum;
    console.log("got passed", value);
    sum += value;
  }
}

const iterableObject = sumGenerator(1);
for (const add of [undefined, 2, 3]) {
  const returnedValue = iterableObject.next(add).value;
  console.log("returned value is", returnedValue);
}
----
*
1[5],2,10[7],11[9] > ''
```

---

```typescript Flow Control from the Caller: injecting an Error
function* generateFib() {
  let a = 0,
    b = 1;
  try {
    while (true) {
      yield a;
      const _ = a + b;
      a = b;
      b = _;
    }
  } catch (e) {
    console.log("guess I went too far.");
  }
}

const iterableFib = generateFib();
for (const fib of iterableFib) {
  console.log(fib);
  if (fib > 100) {
    iterableFib.throw("stop this nonsense!");
  }
}
```

---

```typescript Flow Control from the Caller: forcing to return
function* generateFib() {
  let a = 0,
    b = 1;
  try {
    while (true) {
      try {
        yield a;
      } catch (e) {
        console.log("you will never stop me with", e);
      }
      const _ = a + b;
      a = b;
      b = _;
    }
  } finally {
    console.log("oh, you got me nonetheless.");
  }
}

const iterableFib = generateFib();
for (const fib of iterableFib) {
  console.log(fib);
  iterableFib.throw("stop.");
  if (fib > 100) {
    iterableFib.return("stop this nonsense!");
    // returns { done: true, value: "stop this nonsense!" }
  }
}
```

---

# Some nuances we skipped over

(you'll probably never ever need those)

- you can also `return` from a Generator Function instead of `yield`ing <br/> (the next call to `next` will return `{done: true, value: 'your-return-value'}`)
- you can override the return value that is forced by `myIterator.return("forced-return-value")` <br/> by returning something different in your `finally` block

---

# Let's look at real-world use cases

---

```typescript Generator use-case: early implementation of async/await
```

---

```typescript Generator use-case: sagas
```

# Time for Questions & Discussion

---

# By the way...

# We are hiring!

<img
  src="./assets/mayflower_logo_transparent.png"
  style={{ maxWidth: "50%" }}
/>

(talk to me)
